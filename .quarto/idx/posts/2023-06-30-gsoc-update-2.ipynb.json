{"title":"Google Summer of Code - Average Predictive Comparisons","markdown":{"yaml":{"title":"Google Summer of Code - Average Predictive Comparisons","author":"Gabriel Stechschulte","categories":["open-source","python","bayesian-statistics"],"date":"2023-06-30","jupyter":"python3"},"headingText":"Average predictive comparisons","containsRefs":false,"markdown":"\n\nIt is currently the end of week five of Google Summer of Code 2023. According to the original deliverables table outlined in my proposal, the goal was to have opened a draft PR for the core functionality of the `plot_comparisons`. Subsequently, week six and seven were to be spent further developing the `plot_comparisons` function, and writing tests and a demo notebook for the documentation, respectively. However, at the end of week five, I have a PR open with the majority of the functionality that [marginaleffects](https://vincentarelbundock.github.io/marginaleffects/) has. In addition, I also exposed the `comparisons` function, added tests (which can and will be improved), and have started on documentation.\n\n\n`comparisons` and `plot_comparisons` are a part of Bambi's sub-package `plots` that feature a set of functions used to interpret complex regression models. This sub-package is inspired by the R package [marginaleffects](https://vincentarelbundock.github.io/marginaleffects/articles/predictions.html#conditional-adjusted-predictions-plot). These two functions allow the modeler to **compare** the predictions made by a model for different contrasts and covariate values.\n\nDue to the link function in a GLM, there are typically three quantities of interest to interpret:\n\n1. the linear predictor $\\eta = X\\beta$ where $X$ is an $n$ x $p$ matrix of explanatory variables.\n2. the mean $\\mu = g^{-1}(\\eta)$ where the link function $g(\\cdot)$ relates the linear predictor to the mean of the outcome variable $\\mu = g^{-1}(\\eta) = g^{-1}(X\\beta)$\n3. the response variable $Y \\sim \\mathcal{D}(\\mu, \\theta)$ where $\\mu$ is the mean parameter and $\\theta$ is (possibly) a vector that contains all the other \"nuissance\" parameters of the distribution.\n \nWith GLMs, $\\eta$ is linear in the parameters, but non-linear in relation to the outputs $Y$ due to the link function $g$. Thus, as modelers, we are usually more interested in interpreting (2) and (3). For example, in logistic regression, the linear predictor is on the log-odds scale, but the response variable is on the probability scale. In Poisson regression, the linear predictor is on the log-scale, but the response variable is on the count scale. Referring back to logistic regression, a specified difference in one of the $x$ variables does _not_ correspond to a constant difference in the the probability of the outcome.\n\nIt is often helpful with GLMs, to the modeler and audience, to have a summary that gives the expected difference in the outcome corresponding to a unit difference in each of the input variables. Thus, the goal of `comparisons` and `plot_comparisons` is to provide the modeler with a summary and visualization of the average predicted comparisons.\n\n## Methodology\n\nHere, I adopt the notation from Chapter 14.4 of [Regression and Other Stories](https://avehtari.github.io/ROS-Examples/) to describe the methodology of average predicted comparisons. \n\nAssume we have fit a Bambi model predicting an outcome $Y$ based on inputs $X$ and parameters $\\theta$. Consider the following scalar inputs:\n\n$$u: \\text{the input of interest}$$\n$$v: \\text{all the other inputs}$$\n$$X = (u, v)$$\n\nSuppose for the input of interest, we are interested in comparing $u^{\\text{high}}$ to $u^{\\text{low}}$ (perhaps age = $60$ and $40$ respectively) with all other inputs $v$ held constant. The _predictive difference_ in the outcome changing **only** $u$ is:\n\n$$\\text{predictive difference (comparison)} = \\mathbb{E}(y|u^{\\text{high}}, v, \\theta) - \\mathbb{E}(y|u^{\\text{low}}, v, \\theta)$$\n\nSelecting the maximum and minimum values of $u$ and averaging over all other inputs $v$ in the data gives you a new \"hypothetical\" dataset and corresponds to counting all pairs of transitions of $(u^\\text{low})$ to $(u^\\text{high})$, i.e., differences in $u$ with $v$ held constant. \n\n## Implementation\n\nTo demonstrase how to compute and plot _average predictive comparisons_ with `comparisons` and `plot_comparions`, we model and predict how many fish are caught by visitors at a state park. Many visitors catch zero fish, either because they did not fish at all, or because they were unlucky. We would like to explicitly model this bimodal behavior (zero versus non-zero) using a Zero Inflated Poisson model, and to compare how different inputs of interest $u$ and other covariate values $v$ are associated with the number of fish caught.\n\n### Default contrast and conditional values\n\nIn both `plot_comparisons` and `comparisons`, $u$ and $v$ are represented by `contrast` and `conditional`, respectively. Lets say we are interested in comparing the number of fish caught for `livebait` = [0, 1] conditional on the number of people.\n\nBy default, if no value is passed with `contrast`, then the mean or mode is computed (depending on the data type used to fit the model) as the contrast value. As live bait is category data type and no value was passed, the contrast value is [0, 1]. By default, `comparisons` compares $u^\\text{high}$ to $u^\\text{low}$. Thus, in this example, $u^\\text{high}$ = 1 and $u^\\text{low}$ = 0. The plot shows us that comparing a group of two people who used live bait and no live bait, the expected difference in the number of fish caught is about $2$. As the number of people in the group increases, the expected difference also increases. \n\nWe can call `comparisons` directly to view a summary dataframe that includes the term $u$ and its contrast, the specified `conditional` covariate, and the expected difference in the outcome with the uncertainty interval (by default the 94% highest density interval is computed). We see that `camper` and `child` are also in the summary dataframe. This is because for unspecified covariates, `comparisons` and `plot_comparisons` computes a default value (mean or mode based on the data type of the covariate). Thus, $v$ = `persons`, `camper`, `child`.\n\nFurthermore, `conditional` is not limited to one covariate. We can pass a list of covariates to condition on. For example, we can also include `camper`.\n\n### Unit level contrasts\n\nEvaluating average predictive comparisons at central values for the conditional covariates $v$ can be problematic when the inputs have a large variance since no single central value (mean, median, etc.) is representative of the covariate. This is especially true when $v$ exhibits bi or multimodality. Thus, it may be desireable to use the empirical distribution of $v$ to compute the predictive comparisons, and then average over a specific or set of covariates to obtain the average predictive comparisons. To achieve unit level contrasts, do not pass a parameter into `conditional` and or specify `None`.\n\n#### Marginalizing over covariates\n\nSince the empirical distrubution is used for computing the average predictive comparisons, the same number of rows (250) is returned as the data used to fit the model. To average over a covariate, use the `average_by` argument. If `True` is passed, then `comparisons` averages over all covariates. Else, if a single or list of covariates are passed, then `comparisons` averages by the covariates passed.\n\nIt is still possible to use `plot_comparisons` when passing an argument to `average_by`. In the plot below, the empirical distribution is used to compute unit level contrasts for `livebait` and then averaged over `persons` to obtain the average predictive comparisons. The plot below is similar to the second plot in this notebook. The differences being that: (1) a pairwise transition grid is defined for the second plot above, whereas the empirical distribution is used in the plot below, and (2) in the plot below, we marginalized over the other covariates in the model (thus the reason for not having a camper group, and a reduction in the uncertainty interval).\n\n### User specified contrast and conditional values\n\nThe modeller can also pass their own values for `contrast` and `conditional` by using a dictionary where the key, value pairs are the covariate and value(s) to use. For example, if we wanted to compare the number of fish caught for $4$ versus $1$ `persons` conditional on a range of `child` and `livebait` values, we would pass the following dictionary. However, the user is not limited to passing a list for the values. A `np.array` can also be used.\n\nNotably, comparing $4$ to $1$ persons given $0$ children and using livebait, the expected difference is about $26$ fish. When not using livebait, the expected difference decreases substantially to about $5$ fish. Using livebait with a group of people is associated with a much larger expected difference in the number of fish caught. Oh, and don't bring children fishing if you have plans to catch dinner.\n\n### Multiple contrast values\n\nUsers can also perform comparisons on multiple contrast values. For example, if we wanted to compare the number of fish caught between $(1, 2)$, $(1, 4)$, and $(2, 4)$ `persons` conditional on a range of values for `child` and `livebait`.\n\nNotice how the contrast $u$ varies while the covariates $v$ are held constant. Currently, however, plotting multiple contrast values can be difficult to interpret since the contrast is \"abstracted\" away onto the y-axis. Thus, it would be difficult to interpret which portion of the plot corresponds to which contrast value. This is something I am still working on.\n\n### Conclusion\n\nOverall, solid progress has been made with `comparisons` and `plot_comparisons` to give the Bambi modeller insights into GLMs. One of the most difficult aspects to program is the building of the contrast dataframe (the output above) as it requires tedious shape handling to ensure the predictive comparisons are \"mapped\" to the correct contrast and conditional values. Writing better tests to ensure shapes are correct is something I am also working on. Additionally, there are still \"nice to have\" features such as:\n\n* cross-contrasts\n* comparisons other than the predictive difference (e.g., adjusted risk ratio)\n","srcMarkdownNoYaml":"\n\nIt is currently the end of week five of Google Summer of Code 2023. According to the original deliverables table outlined in my proposal, the goal was to have opened a draft PR for the core functionality of the `plot_comparisons`. Subsequently, week six and seven were to be spent further developing the `plot_comparisons` function, and writing tests and a demo notebook for the documentation, respectively. However, at the end of week five, I have a PR open with the majority of the functionality that [marginaleffects](https://vincentarelbundock.github.io/marginaleffects/) has. In addition, I also exposed the `comparisons` function, added tests (which can and will be improved), and have started on documentation.\n\n# Average predictive comparisons\n\n`comparisons` and `plot_comparisons` are a part of Bambi's sub-package `plots` that feature a set of functions used to interpret complex regression models. This sub-package is inspired by the R package [marginaleffects](https://vincentarelbundock.github.io/marginaleffects/articles/predictions.html#conditional-adjusted-predictions-plot). These two functions allow the modeler to **compare** the predictions made by a model for different contrasts and covariate values.\n\nDue to the link function in a GLM, there are typically three quantities of interest to interpret:\n\n1. the linear predictor $\\eta = X\\beta$ where $X$ is an $n$ x $p$ matrix of explanatory variables.\n2. the mean $\\mu = g^{-1}(\\eta)$ where the link function $g(\\cdot)$ relates the linear predictor to the mean of the outcome variable $\\mu = g^{-1}(\\eta) = g^{-1}(X\\beta)$\n3. the response variable $Y \\sim \\mathcal{D}(\\mu, \\theta)$ where $\\mu$ is the mean parameter and $\\theta$ is (possibly) a vector that contains all the other \"nuissance\" parameters of the distribution.\n \nWith GLMs, $\\eta$ is linear in the parameters, but non-linear in relation to the outputs $Y$ due to the link function $g$. Thus, as modelers, we are usually more interested in interpreting (2) and (3). For example, in logistic regression, the linear predictor is on the log-odds scale, but the response variable is on the probability scale. In Poisson regression, the linear predictor is on the log-scale, but the response variable is on the count scale. Referring back to logistic regression, a specified difference in one of the $x$ variables does _not_ correspond to a constant difference in the the probability of the outcome.\n\nIt is often helpful with GLMs, to the modeler and audience, to have a summary that gives the expected difference in the outcome corresponding to a unit difference in each of the input variables. Thus, the goal of `comparisons` and `plot_comparisons` is to provide the modeler with a summary and visualization of the average predicted comparisons.\n\n## Methodology\n\nHere, I adopt the notation from Chapter 14.4 of [Regression and Other Stories](https://avehtari.github.io/ROS-Examples/) to describe the methodology of average predicted comparisons. \n\nAssume we have fit a Bambi model predicting an outcome $Y$ based on inputs $X$ and parameters $\\theta$. Consider the following scalar inputs:\n\n$$u: \\text{the input of interest}$$\n$$v: \\text{all the other inputs}$$\n$$X = (u, v)$$\n\nSuppose for the input of interest, we are interested in comparing $u^{\\text{high}}$ to $u^{\\text{low}}$ (perhaps age = $60$ and $40$ respectively) with all other inputs $v$ held constant. The _predictive difference_ in the outcome changing **only** $u$ is:\n\n$$\\text{predictive difference (comparison)} = \\mathbb{E}(y|u^{\\text{high}}, v, \\theta) - \\mathbb{E}(y|u^{\\text{low}}, v, \\theta)$$\n\nSelecting the maximum and minimum values of $u$ and averaging over all other inputs $v$ in the data gives you a new \"hypothetical\" dataset and corresponds to counting all pairs of transitions of $(u^\\text{low})$ to $(u^\\text{high})$, i.e., differences in $u$ with $v$ held constant. \n\n## Implementation\n\nTo demonstrase how to compute and plot _average predictive comparisons_ with `comparisons` and `plot_comparions`, we model and predict how many fish are caught by visitors at a state park. Many visitors catch zero fish, either because they did not fish at all, or because they were unlucky. We would like to explicitly model this bimodal behavior (zero versus non-zero) using a Zero Inflated Poisson model, and to compare how different inputs of interest $u$ and other covariate values $v$ are associated with the number of fish caught.\n\n### Default contrast and conditional values\n\nIn both `plot_comparisons` and `comparisons`, $u$ and $v$ are represented by `contrast` and `conditional`, respectively. Lets say we are interested in comparing the number of fish caught for `livebait` = [0, 1] conditional on the number of people.\n\nBy default, if no value is passed with `contrast`, then the mean or mode is computed (depending on the data type used to fit the model) as the contrast value. As live bait is category data type and no value was passed, the contrast value is [0, 1]. By default, `comparisons` compares $u^\\text{high}$ to $u^\\text{low}$. Thus, in this example, $u^\\text{high}$ = 1 and $u^\\text{low}$ = 0. The plot shows us that comparing a group of two people who used live bait and no live bait, the expected difference in the number of fish caught is about $2$. As the number of people in the group increases, the expected difference also increases. \n\nWe can call `comparisons` directly to view a summary dataframe that includes the term $u$ and its contrast, the specified `conditional` covariate, and the expected difference in the outcome with the uncertainty interval (by default the 94% highest density interval is computed). We see that `camper` and `child` are also in the summary dataframe. This is because for unspecified covariates, `comparisons` and `plot_comparisons` computes a default value (mean or mode based on the data type of the covariate). Thus, $v$ = `persons`, `camper`, `child`.\n\nFurthermore, `conditional` is not limited to one covariate. We can pass a list of covariates to condition on. For example, we can also include `camper`.\n\n### Unit level contrasts\n\nEvaluating average predictive comparisons at central values for the conditional covariates $v$ can be problematic when the inputs have a large variance since no single central value (mean, median, etc.) is representative of the covariate. This is especially true when $v$ exhibits bi or multimodality. Thus, it may be desireable to use the empirical distribution of $v$ to compute the predictive comparisons, and then average over a specific or set of covariates to obtain the average predictive comparisons. To achieve unit level contrasts, do not pass a parameter into `conditional` and or specify `None`.\n\n#### Marginalizing over covariates\n\nSince the empirical distrubution is used for computing the average predictive comparisons, the same number of rows (250) is returned as the data used to fit the model. To average over a covariate, use the `average_by` argument. If `True` is passed, then `comparisons` averages over all covariates. Else, if a single or list of covariates are passed, then `comparisons` averages by the covariates passed.\n\nIt is still possible to use `plot_comparisons` when passing an argument to `average_by`. In the plot below, the empirical distribution is used to compute unit level contrasts for `livebait` and then averaged over `persons` to obtain the average predictive comparisons. The plot below is similar to the second plot in this notebook. The differences being that: (1) a pairwise transition grid is defined for the second plot above, whereas the empirical distribution is used in the plot below, and (2) in the plot below, we marginalized over the other covariates in the model (thus the reason for not having a camper group, and a reduction in the uncertainty interval).\n\n### User specified contrast and conditional values\n\nThe modeller can also pass their own values for `contrast` and `conditional` by using a dictionary where the key, value pairs are the covariate and value(s) to use. For example, if we wanted to compare the number of fish caught for $4$ versus $1$ `persons` conditional on a range of `child` and `livebait` values, we would pass the following dictionary. However, the user is not limited to passing a list for the values. A `np.array` can also be used.\n\nNotably, comparing $4$ to $1$ persons given $0$ children and using livebait, the expected difference is about $26$ fish. When not using livebait, the expected difference decreases substantially to about $5$ fish. Using livebait with a group of people is associated with a much larger expected difference in the number of fish caught. Oh, and don't bring children fishing if you have plans to catch dinner.\n\n### Multiple contrast values\n\nUsers can also perform comparisons on multiple contrast values. For example, if we wanted to compare the number of fish caught between $(1, 2)$, $(1, 4)$, and $(2, 4)$ `persons` conditional on a range of values for `child` and `livebait`.\n\nNotice how the contrast $u$ varies while the covariates $v$ are held constant. Currently, however, plotting multiple contrast values can be difficult to interpret since the contrast is \"abstracted\" away onto the y-axis. Thus, it would be difficult to interpret which portion of the plot corresponds to which contrast value. This is something I am still working on.\n\n### Conclusion\n\nOverall, solid progress has been made with `comparisons` and `plot_comparisons` to give the Bambi modeller insights into GLMs. One of the most difficult aspects to program is the building of the contrast dataframe (the output above) as it requires tedious shape handling to ensure the predictive comparisons are \"mapped\" to the correct contrast and conditional values. Writing better tests to ensure shapes are correct is something I am also working on. Additionally, there are still \"nice to have\" features such as:\n\n* cross-contrasts\n* comparisons other than the predictive difference (e.g., adjusted risk ratio)\n"},"formats":{"html":{"identifier":{"display-name":"HTML","target-format":"html","base-format":"html"},"execute":{"fig-width":7,"fig-height":5,"fig-format":"retina","fig-dpi":96,"df-print":"default","error":false,"eval":true,"cache":null,"freeze":true,"echo":true,"output":true,"warning":true,"include":true,"keep-md":false,"keep-ipynb":false,"ipynb":null,"enabled":false,"daemon":null,"daemon-restart":false,"debug":false,"ipynb-filters":[],"engine":"jupyter"},"render":{"keep-tex":false,"keep-source":false,"keep-hidden":false,"prefer-html":false,"output-divs":true,"output-ext":"html","fig-align":"default","fig-pos":null,"fig-env":null,"code-fold":"none","code-overflow":"scroll","code-link":false,"code-line-numbers":false,"code-tools":false,"tbl-colwidths":"auto","merge-includes":true,"inline-includes":false,"latex-auto-mk":true,"latex-auto-install":true,"latex-clean":true,"latex-max-runs":10,"latex-makeindex":"makeindex","latex-makeindex-opts":[],"latex-tlmgr-opts":[],"latex-input-paths":[],"latex-output-dir":null,"link-external-icon":false,"link-external-newwindow":false,"self-contained-math":false,"format-resources":[],"notebook-links":true,"format-links":true},"pandoc":{"standalone":true,"wrap":"none","default-image-extension":"png","to":"html","css":["../styles.css"],"output-file":"2023-06-30-gsoc-update-2.html"},"language":{"toc-title-document":"Table of contents","toc-title-website":"On this page","related-formats-title":"Other Formats","related-notebooks-title":"Notebooks","source-notebooks-prefix":"Source","section-title-abstract":"Abstract","section-title-appendices":"Appendices","section-title-footnotes":"Footnotes","section-title-references":"References","section-title-reuse":"Reuse","section-title-copyright":"Copyright","section-title-citation":"Citation","appendix-attribution-cite-as":"For attribution, please cite this work as:","appendix-attribution-bibtex":"BibTeX citation:","title-block-author-single":"Author","title-block-author-plural":"Authors","title-block-affiliation-single":"Affiliation","title-block-affiliation-plural":"Affiliations","title-block-published":"Published","title-block-modified":"Modified","callout-tip-title":"Tip","callout-note-title":"Note","callout-warning-title":"Warning","callout-important-title":"Important","callout-caution-title":"Caution","code-summary":"Code","code-tools-menu-caption":"Code","code-tools-show-all-code":"Show All Code","code-tools-hide-all-code":"Hide All Code","code-tools-view-source":"View Source","code-tools-source-code":"Source Code","code-line":"Line","code-lines":"Lines","copy-button-tooltip":"Copy to Clipboard","copy-button-tooltip-success":"Copied!","repo-action-links-edit":"Edit this page","repo-action-links-source":"View source","repo-action-links-issue":"Report an issue","back-to-top":"Back to top","search-no-results-text":"No results","search-matching-documents-text":"matching documents","search-copy-link-title":"Copy link to search","search-hide-matches-text":"Hide additional matches","search-more-match-text":"more match in this document","search-more-matches-text":"more matches in this document","search-clear-button-title":"Clear","search-detached-cancel-button-title":"Cancel","search-submit-button-title":"Submit","search":"Search","toggle-section":"Toggle section","toggle-sidebar":"Toggle sidebar navigation","toggle-dark-mode":"Toggle dark mode","toggle-reader-mode":"Toggle reader mode","toggle-navigation":"Toggle navigation","crossref-fig-title":"Figure","crossref-tbl-title":"Table","crossref-lst-title":"Listing","crossref-thm-title":"Theorem","crossref-lem-title":"Lemma","crossref-cor-title":"Corollary","crossref-prp-title":"Proposition","crossref-cnj-title":"Conjecture","crossref-def-title":"Definition","crossref-exm-title":"Example","crossref-exr-title":"Exercise","crossref-ch-prefix":"Chapter","crossref-apx-prefix":"Appendix","crossref-sec-prefix":"Section","crossref-eq-prefix":"Equation","crossref-lof-title":"List of Figures","crossref-lot-title":"List of Tables","crossref-lol-title":"List of Listings","environment-proof-title":"Proof","environment-remark-title":"Remark","environment-solution-title":"Solution","listing-page-order-by":"Order By","listing-page-order-by-default":"Default","listing-page-order-by-date-asc":"Oldest","listing-page-order-by-date-desc":"Newest","listing-page-order-by-number-desc":"High to Low","listing-page-order-by-number-asc":"Low to High","listing-page-field-date":"Date","listing-page-field-title":"Title","listing-page-field-description":"Description","listing-page-field-author":"Author","listing-page-field-filename":"File Name","listing-page-field-filemodified":"Modified","listing-page-field-subtitle":"Subtitle","listing-page-field-readingtime":"Reading Time","listing-page-field-categories":"Categories","listing-page-minutes-compact":"{0} min","listing-page-category-all":"All","listing-page-no-matches":"No matching items"},"metadata":{"lang":"en","fig-responsive":true,"quarto-version":"1.3.306","theme":"sketchy","title-block-banner":true,"title":"Google Summer of Code - Average Predictive Comparisons","author":"Gabriel Stechschulte","categories":["open-source","python","bayesian-statistics"],"date":"2023-06-30","jupyter":"python3"},"extensions":{"book":{"multiFile":true}}}},"projectFormats":["html"]}